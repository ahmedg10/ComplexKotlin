/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package edu.uw.complexkotlin

class Library {
    fun someLibraryMethod(): Boolean {
        return true
    }
}

// write a lambda using map and fold to solve "FIZZBUZZ" for the first fifteen numbers (0..15).
// use map() to return a list with "", "FIZZ" (for 3s) or "BUZZ" (for 5s).
// use fold() to compress the array of strings down into a single string.
// the final string should look like FIZZBUZZFIZZFIZZBUZZFIZZFIZZBUZZ for 0..15.
// store this lambda into 'fizzbuzz' so that the tests can call it
//

//Intalizing the variable and we will have to use ":""
//Additoanlly (Int Range) is what we are going to take in


val fizzbuzz : (IntRange) -> String =  {range -> 
    range.map {
        //it is the place holder for each 
        when(it){
            in listOf(15) -> "FIZZBUZZ"
            in listOf(3, 6, 9, 12, 15) -> "FIZZ"
            in listOf(5, 10, 15) -> "BUZZ"
            else -> ""
        }

    }.fold("", { acc, elem -> acc + elem } )
}

val fizzbuzz2: (IntRange) -> String = { nums -> 
    nums.map { 
        when {
            //Extra Credit: Up to 100
            //this conditonal fits for 15
            it % 3 == 0 && it % 5 == 0 -> "FIZZBUZZ"
            
            //this fits for numbers 3, 6, 9, 12, 15
            it % 3 == 0 -> "FIZZ"
            //this fits 
            it % 5 == 0 -> "BUZZ"
        
            // Extra Credit: New case for numbers divisible by 7
            it % 7 == 0 -> "DOH!"
            else -> ""
    }}.fold("", { acc, elem -> acc + elem } )
}



// This is a utility function for your use as you choose, and as an
// example of an extension method

//add new functionality to existing classes without modifying their source code. 
fun Int.times(block: () -> Unit) {
    for (it in 1..this) {
        block()
    }
}

// Use this function
fun process(message: String, block: (String) -> String): String {
    return ">>> ${message}: {" + block(message) + "}"
}
//
val r1 = { process("FOO") { "BAR"} }

// Create r2 as a lambda that calls process() with message "FOO" and a block that upper-cases 
// r2_message, and repeats it three times with no spaces: "WOOGAWOOGAWOOGA"
val r2_message = "wooga"
val r2 = { process("FOO") 
    {
        var ret = ""
        3.times {
            ret += r2_message.toUpperCase()
        }
        //In this case, the lambda block calculates the value of ret and then returns it as the last expression. There's no need for an explicit return statement
        ret
    } 
}


// write an enum-based state machine between talking and thinking
//Enum class is set of choices and states
//Think of it like a menu in a restaurant where you can only order items from the menu; you can't ask for something that's not on the menu.
// Enum classes are a great way to do this because philosophers can only be in one of these two states. 
enum class Philosopher {
    THINKING {
        override fun toString() = "Deep thoughts..."
    },
    TALKING {
        override fun toString() = "Allow me to suggest an idea..."
    };

    fun signal(): Philosopher {
        // Toggle the state when signaled
        return when (this) {
            THINKING -> TALKING
            TALKING -> THINKING
        }
    }
}

// create an class "Command" that can be used as a function (provide an "invoke()" function)
// that takes a single parameter ("message" of type String)
// primary constructor should take a String argument ("prompt")
// when invoked, the Command object should return a String containing the prompt and then the message
class Command(val prompt: String) {
    public operator fun invoke(message: String): String {
        return prompt + message
    }
}